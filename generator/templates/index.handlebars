import axios, { AxiosInstance, Method } from 'axios';
import { UnifiedOptions, Response, ListFilter, ListResponse, Count, DeleteOptions, HttpStatusCode } from './types/';
import { convertFilterToQueryParams } from './utils';

export * from './types/generic';
export * from './types/models';

import { 
  {{#each resources}}
    {{this.pascalCase}}{{#unless @last}}, {{/unless}}
  {{/each}} 
} from './types/';

interface UnifiedApi<Type> {
    create(object: Type, options?: UnifiedOptions | undefined | null): Promise<Response<Type>>;
    list(filter?: ListFilter | undefined | null, options?: UnifiedOptions | undefined | null): Promise<ListResponse<Type>>;
    get(id: string, options?: UnifiedOptions | undefined | null): Promise<Response<Type>>;
    update(id: string, object: Type, options?: UnifiedOptions | undefined | null): Promise<Response<Type>>;
    count(options?: UnifiedOptions | undefined | null): Promise<Response<Count>>;
    delete(id: string, deleteOptions?: DeleteOptions | undefined | null, options?: UnifiedOptions | undefined | null): Promise<Response<Type>>;
}

export class Resource<T> implements UnifiedApi<T> {
    private axiosInstance: AxiosInstance;
    private connectionKey: string;
    private resourceName: string;

    constructor(axiosInstance: AxiosInstance, connectionKey: string, resourceName: string) {
        this.axiosInstance = axiosInstance;
        this.connectionKey = connectionKey;
        this.resourceName = resourceName;
    }

    private getRequestHeaders(options?: UnifiedOptions): Record<string, string> {
        const headers: Record<string, string> = {};
        const excludedKeys = ['common', 'delete', 'get', 'head', 'post', 'put', 'patch'];

        for (const [key, value] of Object.entries(this.axiosInstance.defaults.headers)) {
            if (!excludedKeys.includes(key) && typeof value === 'string') {
                headers[key] = value;
            }
        }

        headers['x-integrationos-connection-key'] = this.connectionKey;
        Object.assign(headers, options?.passthroughHeaders);

        return headers;
    }

    private async makeRequestSingle<R>(
        method: string, 
        url: string, 
        data?: any, 
        options?: UnifiedOptions, 
        queryParams?: Record<string, string>, 
        statusCode?: number
    ): Promise<Response<R>> {
        try {
            const response = await this.axiosInstance.request({
                method: method as Method,
                url,
                data,
                headers: this.getRequestHeaders(options),
                params: { ...queryParams, ...options?.passthroughQuery }
            });

            const output = {
                ...response?.data,
                headers: response.headers as Record<string, string>,
                statusCode: statusCode || response.status
            };

            return output;
        } catch (error: any) {
            throw error.response?.data;
        }
    }

    private async makeRequestList<R>(
        method: string, 
        url: string, 
        data?: any, 
        options?: UnifiedOptions, 
        queryParams?: Record<string, string>, 
        statusCode?: number
    ): Promise<ListResponse<R>> {
        try {
            const response = await this.axiosInstance.request({
                method: method as Method,
                url,
                data,
                headers: this.getRequestHeaders(options),
                params: { ...queryParams, ...options?.passthroughQuery }
            });

            const output = {
                ...response?.data,
                headers: response.headers as Record<string, string>,
                statusCode: statusCode || response.status
            };

            return output;
        } catch (error: any) {
            throw error.response?.data;
        }
    }

    async create(object: T, options?: UnifiedOptions): Promise<Response<T>> {
        return this.makeRequestSingle<T>('POST', `/${this.resourceName}`, object, options, undefined, HttpStatusCode.Created);
    }

    async list(filter?: ListFilter, options?: UnifiedOptions): Promise<ListResponse<T>> {
        const queryParams = convertFilterToQueryParams(filter);
        return this.makeRequestList<T>('GET', `/${this.resourceName}`, undefined, options, queryParams, HttpStatusCode.OK);
    }

    async get(id: string, options?: UnifiedOptions): Promise<Response<T>> {
        return this.makeRequestSingle<T>('GET', `/${this.resourceName}/${id}`, undefined, options, undefined, HttpStatusCode.OK);
    }

    async update(id: string, object: T, options?: UnifiedOptions): Promise<Response<T>> {
        return this.makeRequestSingle<T>('PATCH', `/${this.resourceName}/${id}`, object, options, undefined, HttpStatusCode.NoContent);
    }

    async count(options?: UnifiedOptions): Promise<Response<Count>> {
        return this.makeRequestSingle<Count>('GET', `/${this.resourceName}/count`, undefined, options, undefined, HttpStatusCode.OK);
    }

    async delete(id: string, deleteOptions?: DeleteOptions, options?: UnifiedOptions): Promise<Response<T>> {
        return this.makeRequestSingle<T>('DELETE', `/${this.resourceName}/${id}`, undefined, options, {
            ...deleteOptions,
        }, HttpStatusCode.NoContent);
    }
}

export interface IntegrationOSConfig {
    serverUrl: string
}

export class IntegrationOS {
    private axiosInstance: AxiosInstance;

    constructor(private apiKey: string, options?: IntegrationOSConfig | undefined | null) {
        this.axiosInstance = axios.create({
            baseURL: options?.serverUrl || 'https://api.integrationos.com/v1/unified',
            headers: {
                'x-integrationos-secret': this.apiKey,
                'Content-Type': 'application/json',
            },
        });
    }

    {{#each resources}}
    {{this.camelCase}}(connectionKey: string) {
        return new Resource<{{this.pascalCase}}>(this.axiosInstance, connectionKey, '{{this.lowerCase}}');
    }
    {{/each}}
}